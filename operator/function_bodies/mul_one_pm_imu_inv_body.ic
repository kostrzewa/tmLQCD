// mul_one_pm_imu_inv_body

  _Complex double ALIGN z,w;
  int ix;
  double sign=-1.; 
  spinor *r;

  su3_vector ALIGN phi1;

  double ALIGN nrm = 1./(1.+g_mu*g_mu);

  if(_sign < 0.){
    sign = 1.; 
  }

  z = nrm + (sign * nrm * g_mu) * I;
  w = conj(z);
  /************ loop over all lattice sites ************/
#ifdef OMP
#pragma omp for
#endif
  for(ix = 0; ix < N; ix++){
    r=l + ix;
    /* Multiply the spinorfield with the inverse of 1+imu\gamma_5 */
#if ( defined SSE2 || defined SSE3 )
    _prefetch_spinor((r+predist)); 
    _sse_load_up(r->s0);
    _sse_vector_cmplx_mul(z);
    _sse_store_nt_up(r->s0);
    _sse_load_up(r->s1);
    _sse_vector_cmplx_mul_two();
    _sse_store_nt_up(r->s1);
    _sse_load_up(r->s2);
    _sse_vector_cmplx_mul(w);
    _sse_store_nt_up(r->s2);
    _sse_load_up(r->s3);
    _sse_vector_cmplx_mul_two();
    _sse_store_nt_up(r->s3);
#else
    _complex_times_vector(phi1, z, r->s0);
    _vector_assign(r->s0, phi1);
    _complex_times_vector(phi1, z, r->s1);
    _vector_assign(r->s1, phi1);
    _complex_times_vector(phi1, w, r->s2);
    _vector_assign(r->s2, phi1);
    _complex_times_vector(phi1, w, r->s3);
    _vector_assign(r->s3, phi1);
#endif
  }
